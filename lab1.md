Challenge1: 描述与理解中断流程

1. 处理中断异常的流程：

答：

1. 首先操作系统发现异常并发送给CPU，默认情况下,发生所有异常的时候,控制权都会被移交到 M 模式的异常处理程序然后进行处理，事实上M 模式的异常处理程序也可以将异常重新导向 S 模式，也支持通过异常委托机制选择性地将中断和同步异常直接交给 S 模式处理,而完全绕过 M 模式。
2. 接着CPU开始访问stvec，也就是所谓的”中断向量表基址”，事实上是一个CSR（控制状态寄存器）。stvec最低位的两位用来编码“模式”，如果是“00”就说明更高的SXLEN-2个二进制位存储的是唯一的中断处理程序的地址(SXLEN是stval寄存器的位数)，如果是“01”说明更高的SXLEN-2个二进制位存储的是中断向量表基址，通过不同的异常原因来索引中断向量表。在本实验采用Direct模式,也就是只有一个中断处理程序, PC直接跳转到stvec中的地址，本实验中是_\_alltraps的入口地址。
3. 进入_\_alltraps后，会实现上下文的保存，以便后续的恢复。此时会定义一个trap_frame结构体，里面依存放着通用寄存器x0到x31,然后是4个和中断相关的CSR，然后通过汇编宏SAVE-ALL将这个结构体放入栈顶，即存储其中的内容，之后_\_alltraps使用指令move a0, sp将刚刚保存上下文的中断栈帧的栈顶地址值赋给了函数参数，之后开始调用trap函数进行中断处理。
4. 在trap函数中把中断处理,异常处理的工作分发给了interrupt_handler()，exception_handler(), 这些函数再根据中断或异常的不同类型来处理。实际过程是在trap_dispatch()函数中，根据casue寄存器判断捕捉到的是中断还是异常，中断就调用interrupt_handler()，异常就调用exception_handler()。
5. 最后一切都完成后trap函数返回，再执行_\_trapret部分，内容就是调用RESTORE_ALL汇编宏恢复上下文，然后使用sret指令把sepc的值赋值给pc，即回到原来的程序继续执行。
6. mov a0，sp的目的是什么？

答：

将刚刚保存上下文的中断栈帧的栈顶地址值赋给了a0寄存器，即参数寄存器，这样可以把中断帧的地址作为参数传给trap函数，使其能获得上下文。

1. SAVE_ALL中寄存器保存在栈中的位置是什么确定的？

答：

中断帧及其内部存放的各个寄存器通过栈顶寄存器sp来索引的。指令addi sp, sp, -36 \* REGBYTES，在内存中空出了给寄存器准备的栈空间，这样只要使用sp便能访问需要的上下文。

1. 对于任何中断，\__alltraps 中都需要保存所有寄存器吗？请说明理由。

答：

是的，我们的中断处理流程是固定的程序，即使有的中断可能并不一定刚需保存所有寄存器，但是为了中断处理的规范性和统一性，尽可能保存足够多的信息才是保证有效安全处理的最佳策略。

Challenge2: 理解上下文切换机制

1. 在trapentry.S中汇编代码 csrw sscratch, sp；csrrw s0, sscratch, x0实现了什么操作，目的是什么？

答：

csrw sscratch, sp指令：把中断帧的栈顶指针sp赋值给sscratch特权寄存器。

csrrw s0, sscratch, x0指令：把sscratch寄存器里存储的栈顶指针的值写入s0寄存器，把零寄存器x0赋值给sscratch，实现sscratch的清零。

目的是将sp的值临时保存在sscratch，维护关键数据，并将其传给s0作为参数传给trap函数。

1. save all里面保存了stval scause这些csr，而在restore all里面却不还原它们？那这样store的意义何在呢？

答：

stval scause这两个csr保存的是异常中断的来源信息，比如指令地址和原因之类。我们只在中断程序处理的过程因为需要了解本次中断信息才访问这些csr。中断处理程序结束后，这些信息便不再有用，恢复上下文与其无关，之后可以直接覆盖这两个寄存器，不进行恢复更加方便。主要意义是临时保存中断处理需要的相关来源信息以便查询。